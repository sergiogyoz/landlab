import numpy as np
from landlab import Component  # base class from which components inherit


class DumbC(Component):
    """
    Component doc
    """

    # ----- Required landlab component fields
    # Prefix underscore "intended for internal use only" (pseudo private)
    _name = "SuperDuperComponent"

    _unit_agnostic = True

    _info = {  # here you put the metadata of your class
        "dumb_height": {
            "dtype": float,  # data type
            "intent": "inout",  # is it input or ouput or both?
            "optional": False,  # is it optional?
            "units": "m",  # what units?
            "mapping": "node",  # is it associated to nodes? links? faces? etc
            "doc": "multiplies the height values 'cause... Idk, math",  # description of the field/value
        },
        "topographic__elevation": {
            "dtype": float,
            "intent": "out",
            "optional": False,
            "units": "m",
            "mapping": "node",
            "doc": "Land surface topographic elevation",
        },
    }

    # cite info for autogenerated citations in TeX Bib format
    _cite_as = """@article{leMua2021DumbComponent,
      doi = {55.555/saywa555},
      url = {https://55.555/saywa555},
      year = {2021},
      publisher = {WeGetYourShitOut},
      volume = {1},
      number = {11},
      pages = {111},
      author = {Sergio Villamarin and Jane Gloriana Villanueva},
      title = {Components on landlab: Learn how the fuck to use them},
      journal = {The "I hope to get better" Journal of science}
    }"""

    # ------ Requirements end

    # ------ Constructor begins

    # _init is a the constructor method for the class (component in this case)
    def __init__(self, grid,  # grid should always be a parameter of a landlab component
                 bh=20, s=1):  # my default values for my component field
        """
        Parameters
        ----------
        grid: RasterModelGrid
            A grid.
        a_base_height: float, optional
            A height that I will add to my dumb_height values at every node.
        """  # this is the docstring so python users and IDLEs see a brief explanation of your class/method

        # this goes up to component and inherets all of its fields here, 
        # so everything a component has, our component does too.
        # (essentially a grid)
        super().__init__(grid)

        # my own class values
        self.a_base_height = bh
        self.spread = s

        # check that a reference to my own grid field dumb_height exists
        if "dumb_height" not in self.grid.at_node:
            self._grid.add_zeros("dumb_height", at="node")
        else:  # else, it was already there so I don't need to add one
            pass

        # shorthand reference to dumb height for use in the component
        self.dhs = self._grid.at_node["dumb_height"]
        # like in here
        self._grid.at_node["topographic__elevation"] = self.dhs + self.a_base_height

    # ----- Constructor ends

    # ----- landlab (implicitly) requires a run_one_step or a custom update function

    # if time delta is important for the update then we use this
    def run_one_step(self, dt):
        delta_spread = dt * self.spread
        # better to think in vector terms when manipulating fields
        self._grid.at_node["topographic__elevation"] = self._grid.at_node["topographic__elevation"] + np.random.standard_normal(size=self.dhs.shape) * delta_spread

    # if time delta is not important or is not a temporal update then we use our custom update function
    def update_dumb_heights(self):
        # it may not always be possible to think in vector terms tho
        for i in range(len(self._grid.at_node["topographic__elevation"])):
            self._grid.at_node["topographic__elevation"][i] = self._grid.at_node["topographic__elevation"][i] + np.random.standard_normal() * self.spread

    # ----- custom class methods, getters and setters can go here

    # see decorators for more details on what type of methods a component class can have etc
